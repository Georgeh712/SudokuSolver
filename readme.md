# Sudoku Solver

## Introduction

In this assignment and in the sudoku.ipynb contained alongside this readme file, a python script has been written to solve sudoku's of varying difficulties. This solution implements the use of backtracking depth-first-search with constraint propogation in order to be able to solve more difficult puzzles in a limited time frame. In this method, each variable has a domain, a set of values which the variable could be. Due to the rules of the sudoku puzzle, which are no repeated numbers in any one column, row or 3x3 box of which there are 9, there are constraints on these variables. This means that choosing a value for one of the variables will propagate and effect to the rest of the variables. For example, setting a variable to 3, would mean no 3 can appear in again in the column or row, or 3x3 box in which this variable sits. By doing this, the domain of variables which are contrained by this variable are reduced. This has a chain reaction through the puzzle and can mean that very simple puzzles are solved by only applying the constraint propagation, so no testing or backtracking is required. However, testing and backtracking is required for more advance puzzles.
When testing and backtracking through states, of utmost importance is which variables are chosen to change and what value they are assigned. Choosing one worse value can result in the time taken to reach complete assignment to be much larger than for another value. As the algorithm will only backtrack once a failed solution has been found, choosing the wrong value can send the algorithm down a branch where no correct solution is possible and each partial assignment will have to fail before it can backtrack up to the correct the original value.

## The Code

### Data Structure
Firstly the puzzle must be represented in someway in the code. In this solution, lists and nested lists were used to imitate a grid of numbers as would be seen in a sudoku puzzle. List were chosen for there simplicity to implement and readability for debuggin the code. During testing numpy arrays were breify tried and the speed at which puzzles were solved was analysed leading to the conclusing that numpy arrays were increased the time taken to solve puzzles. However this constradicts some assessments made by others on simple problems [UCF, n.d](https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference). This suggests that the effect the data structure has on the effiency is not only determined by the structure itself but also by what it contains and how it is implemented. In this case the code was originally witten using lists and therefore has been naturally optimised to work with them. Another advantage of using numpy would be the decrease in memory used in comparison to lists [UCF, n.d](https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference). In the case of the testing used for this solution, memory has not been an issue, however with larger puzzle grid sizes memory may become more of a priority.

### Classes and Methods
The general structure of this solution is one class for the sudoku puzzle which works to deinfe and instantiate the state instances, to set and retrieve informatino from the state, and to check for its completion or failure. In addition there are a few supporting methods to setup the intial puzzle and to assign which variables to change and which values to test in this variables. The Sudoku class has attributes for: whether it has failed (boolean), the original puzzle, the possible values (the domain of the variables), the final values (the partial or complete assignment), and a grid which assigns a tag to the coordinates to assist with efficiently checking constraints in the 3x3 box.

The most important function in the Sudoku class is the setValue() function. Here, coordinates are sent and assigned as the final values for the current state. This function then checks the related column and row and removes the value assigned from the domain of all other variables. The function also checks the tag of the coordinates for its decription box location and only the boxes with the matching tag are check, and the variable removed from their domains also. Finally, the function checks whether any variables in the puzzle have only one value in their domain, and if they do it is assigned as a final value. During this the function also checks for inconsistencies in the constraints. For example, if 6 is assigned to a variable and another variable in that row has a domain containing only 6, then the state is set to a fail and returned.

Leading on from the setValue() function is the recursiveSolve() function, not contained in the Sudoku class, which allows for the depth-first-searching and backtracking. In this function the puzzle is first sent to be setup by taking the array and creating a new Sudoku class from it. In doing so, the setValue() function is used and in some cases the constraint propagation alone in this function is enough to solve the puzzle and find a complete assignment. If this isn't the case then a new state is instanstiated and setValue() is used to test a value in one of the variables. If the state does not fail this is repeated using recursion by calling the same function again. This continues until one of two cases. Either the state fails and the recusrion backtracks to the previous state and tries the next value in the queue or switches to trying values in the next variable in the queue, or the state passes, a complete assignment is found and this is returned through all the recusive steps back to the start and returned as a pass.

Using this method alone and randomly selecting which variables to try next and which values to use will result in a complete assignment, however it may not be the optimal path to finding it. By defining a better way to select the variables and values, the time taken to find the solution can be greatly decreased.

Selecting the variables is done using the pickNextElement() function. Instead of randomly selecting, this function will look for the variables which have the smallest domains. As one would if they were solving a sudoku by hand, one would look for a variable which only has one value in its domain, as there is nothing else it can be, it can be assinged, the next best would be two and then three and so on. This methodology also works with this algorithm. For example, doing the contrary and choosing variables with the largest domains has resulted in completion times for harder puzzles of between 2 and 4 minutes, but when looking for smaller domains, these times are reduced to under a second in some cases, thus justifying the importance of choice prioritisation for the algorithm. In terms of probability, one has a higher chance of choosing the correct value from a smaller domain than from a larger one.

Selecting which values to use, or creating a queue for which to try them in is done using the orderValues() function. This first scans the puzzle, ignoring variables which already have a final value and counting the instances of values in the remaining domains of unassigned variables. From a logical sense, if a value only appears once then it has to be assigned to that variable as it has nowhere else to go. The probability of this being the correct choice then drops off as the amount that value appears increases. This method is called the least-constraining value, a heuristic used to choose a value which rules out the least amount of values from other domains.

### Efficiencies
There were two major points of inefficiency in my code that i found solutions to. One was regarding checking the 3x3 box to remove any values from domains which I had just assigned to another vairable. Originally the code would scan through the whole puzzle to see if the location tags matched, even if the top left box was in question, it would continue to scan through the rest of the puzzle. This was solved by coding in the coordinates for each box and assigning those to the scan range when that location was being checked. As this part of the function was used frequently (every time a value was assigned), this had a noticeable effect on reducing the time taken to solve.

Secondly was the deepcopy() function from the copy library of python which I found to be slowing the program significantly. The function will create a copy of the object it is given and "...recursively, inserts copies into it of the objects found in the original." [Python, n.d](https://docs.python.org/3/library/copy.html). I searched for a quicker solution to deepcopy() and found pickle() another python method which serialises the object, meaning it is converted in byte stream data [Python, n.d](https://docs.python.org/3/library/pickle.html). Alternatively the deepcopy() function can be redefined to increase its speed but this was not tested. Testing the speed between using deepcopy() and pickle() produced the following results. Hard puzzles deepcopy() - 3.1 seconds to complete, hard puzzle pickle() - 1.9 seconds to complete. The pickle() function worked in the case of this program, however the deepcopy() function is more general and will work in a greater variety of cases.

## Summary
The algorithm used in this solution to the Sudoku problem, depth-first-search backtracking with constraint propagation was suitable to the problem and was able to handle even the harder puzzles within a short period of time. The algorithm is not fool proof however, as it must be coded to create the right choices before it goes to far to the wrong path. The most significant increases in its performance were found by altering the order in which the variables are chosen and the order in which values are tried for those variables.

## Bibliography
UCF, n.d. Python Lists vs. Numpy Arrays - What is the difference?\[Online\]UCF, Available from: https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference \[Accessed 20 September 2022\]

Python, n.d. copy — Shallow and deep copy operations\[Online\]Python, Available from:https://docs.python.org/3/library/copy.html \[Accessed 20 September 2022\]

Python, n.d. pickle — Python object serialization\[Online\]Python, Available from:https://docs.python.org/3/library/pickle.html \[Accessed 20 September 2022\]